# V5 Database Schema Documentation

**Database**: `parking_v5`
**PostgreSQL Version**: 16.10
**Last Updated**: 2025-10-25
**Schema Version**: V5.4.0 (Multi-Tenancy + Production Hardening + Loose Coupling)

---

## Table of Contents

1. [Overview](#overview)
2. [Entity Relationship Diagram](#entity-relationship-diagram)
3. [Multi-Tenancy Hierarchy](#multi-tenancy-hierarchy)
4. [Core Tables](#core-tables)
   - [tenants](#tenants)
   - [sites](#sites)
   - [spaces](#spaces)
   - [users](#users)
   - [user_memberships](#user_memberships)
5. [Device Tables](#device-tables)
   - [device_types](#device_types)
   - [sensor_devices](#sensor_devices)
   - [display_devices](#display_devices)
   - [device_assignments](#device_assignments)
6. [Operational Tables](#operational-tables)
   - [reservations](#reservations)
   - [sensor_readings](#sensor_readings)
   - [actuations](#actuations)
   - [state_changes](#state_changes)
7. [Policy & Control Tables](#policy--control-tables)
   - [display_policies](#display_policies)
   - [sensor_debounce_state](#sensor_debounce_state)
   - [space_admin_overrides](#space_admin_overrides)
8. [Authentication Tables](#authentication-tables)
   - [api_keys](#api_keys)
   - [refresh_tokens](#refresh_tokens)
   - [webhook_secrets](#webhook_secrets)
9. [Foreign Key Relationships](#foreign-key-relationships)
10. [Indexes & Performance](#indexes--performance)
11. [Row-Level Security (RLS)](#row-level-security-rls)
12. [Triggers & Functions](#triggers--functions)

---

## Overview

The V5 database schema is architected for **multi-tenant parking management** with:

- **19 tables** organized in a hierarchical multi-tenant model
- **Complete tenant isolation** via `tenant_id` foreign keys and Row-Level Security (RLS)
- **Platform admin support** - super-admin access via `is_platform_admin` flag
- **24 foreign key relationships** ensuring referential integrity
- **EUI normalization** - all LoRaWAN device identifiers stored as UPPERCASE hex (16 chars)
- **Loose device-tenant coupling** - devices exist independently, assigned via FK references
- **Device lifecycle management** - orphan → active → inactive → decommissioned
- **Device assignment audit trail** - `device_assignments` table tracks all assignment history
- **Reservation overlap prevention** using PostgreSQL EXCLUDE constraints
- **Idempotency support** via `request_id` fields for safe retries

---

## Entity Relationship Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            TENANTS (Root)                                │
│  - Tenant organizations (customers using the platform)                  │
└──────────┬──────────────────────────────────────────────────────────────┘
           │
           ├── ON DELETE CASCADE ──> sites (physical locations)
           ├── ON DELETE CASCADE ──> user_memberships (user-tenant-role)
           ├── ON DELETE CASCADE ──> api_keys (API authentication)
           ├── ON DELETE CASCADE ──> webhook_secrets (webhook signing keys)
           ├── ON DELETE CASCADE ──> display_policies (display control rules)
           ├── ON DELETE CASCADE ──> reservations (parking reservations)
           └── ON DELETE CASCADE ──> space_admin_overrides (admin overrides)

┌─────────────────────────────────────────────────────────────────────────┐
│                                 SITES                                    │
│  - Physical locations per tenant (buildings, parking lots)              │
└──────────┬──────────────────────────────────────────────────────────────┘
           │
           └── ON DELETE RESTRICT ──> spaces (parking spaces)

┌─────────────────────────────────────────────────────────────────────────┐
│                                SPACES                                    │
│  - Individual parking spaces with sensor/display assignments            │
└──────────┬──────────────────────────────────────────────────────────────┘
           │
           ├── sensor_device_id ──> sensor_devices (motion sensor)
           ├── display_device_id ──> display_devices (LED indicator)
           │
           ├── ON DELETE NO ACTION ──> reservations (parking reservations)
           ├── ON DELETE NO ACTION ──> sensor_readings (time-series sensor data)
           ├── ON DELETE NO ACTION ──> actuations (downlink commands)
           ├── ON DELETE NO ACTION ──> state_changes (audit trail)
           ├── ON DELETE CASCADE ──> sensor_debounce_state (debounce state)
           └── ON DELETE CASCADE ──> space_admin_overrides (admin overrides)

┌─────────────────────────────────────────────────────────────────────────┐
│                            DEVICE_TYPES                                  │
│  - Catalog of supported device types (sensors, displays)                │
└──────────┬──────────────────────────────────────────────────────────────┘
           │
           ├── ON DELETE NO ACTION ──> sensor_devices
           └── ON DELETE NO ACTION ──> display_devices

┌─────────────────────────────────────────────────────────────────────────┐
│                                USERS                                     │
│  - User accounts (can belong to multiple tenants)                       │
└──────────┬──────────────────────────────────────────────────────────────┘
           │
           ├── ON DELETE CASCADE ──> user_memberships (tenant membership)
           ├── ON DELETE CASCADE ──> refresh_tokens (JWT refresh tokens)
           ├── ON DELETE NO ACTION ──> display_policies.created_by
           └── ON DELETE NO ACTION ──> space_admin_overrides.created_by
```

---

## Multi-Tenancy Hierarchy

The database enforces a strict tenant hierarchy:

```
TENANT
  └── sites (physical locations)
        └── spaces (parking spaces)
              ├── sensor_device (assigned motion sensor)
              ├── display_device (assigned LED indicator)
              ├── reservations (parking reservations for this space)
              ├── sensor_readings (sensor uplinks for this space)
              ├── actuations (downlink commands to display)
              └── state_changes (state transition audit log)
```

**Key Principles**:
1. **Every tenant-specific resource** has a `tenant_id` foreign key
2. **Spaces inherit `tenant_id`** from their parent `site` (auto-synced via trigger)
3. **Deletion cascades down** the hierarchy (delete tenant → deletes all sites, spaces, reservations)
4. **Cannot delete site** if it has active spaces (RESTRICT constraint)
5. **Row-Level Security (RLS)** enforces tenant isolation at database level

---

## Core Tables

### `tenants`

**Purpose**: Root entity for multi-tenancy. Represents customer organizations using the platform.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `name` | varchar(255) | NOT NULL | | Organization name (e.g., "Acme Corporation") |
| `slug` | varchar(100) | NOT NULL | | URL-safe identifier (e.g., "acme") - must match `^[a-z0-9-]+$` |
| `type` | varchar(50) | | `'customer'` | Tenant type: customer, partner, internal |
| `subscription_tier` | varchar(50) | | `'basic'` | Subscription plan: basic, pro, enterprise |
| `metadata` | jsonb | | `'{}'` | Custom tenant metadata |
| `settings` | jsonb | | `'{}'` | Tenant-specific settings (timezone, preferences) |
| `is_active` | boolean | | `true` | Active tenant flag |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Constraints**:
- **PK**: `id`
- **Unique**: `slug`
- **Check**: `slug` must match `^[a-z0-9-]+$` (lowercase alphanumeric + hyphens only)

**Indexes**:
- `idx_tenants_slug` on `slug` WHERE `is_active = true`
- `idx_tenants_active` on `is_active` WHERE `is_active = true`

**Referenced By** (ON DELETE CASCADE):
- `sites.tenant_id`
- `user_memberships.tenant_id`
- `api_keys.tenant_id`
- `webhook_secrets.tenant_id`
- `display_policies.tenant_id`
- `reservations.tenant_id`
- `space_admin_overrides.tenant_id`

**RLS Policy**:
```sql
POLICY "p_tenants_isolation"
  USING (id = current_setting('app.current_tenant')::uuid)
```

**Triggers**:
- `update_tenants_updated_at` - Auto-updates `updated_at` on modifications

---

### `sites`

**Purpose**: Physical locations managed by tenants (buildings, parking lots, campuses).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `name` | varchar(255) | NOT NULL | | Site name (e.g., "Building A Parking") |
| `timezone` | varchar(50) | | `'UTC'` | Site timezone (e.g., "America/New_York") |
| `location` | jsonb | | | GeoJSON or address data |
| `metadata` | jsonb | | `'{}'` | Custom site metadata |
| `is_active` | boolean | | `true` | Active site flag |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Foreign Keys**:
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Unique**: `(tenant_id, name)` - site names must be unique per tenant

**Indexes**:
- `idx_sites_tenant` on `tenant_id` WHERE `is_active = true`
- `idx_sites_tenant_active` on `(tenant_id, is_active)`

**Referenced By**:
- `spaces.site_id` (ON DELETE RESTRICT) - **cannot delete site with active spaces**

**RLS Policy**:
```sql
POLICY "p_sites_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid)
```

**Triggers**:
- `update_sites_updated_at` - Auto-updates `updated_at`

---

### `spaces`

**Purpose**: Individual parking spaces with sensor/display device assignments.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (auto-synced from site) |
| `site_id` | uuid | NOT NULL | | **FK → sites.id** (ON DELETE RESTRICT) |
| `name` | varchar(100) | NOT NULL | | Space display name (e.g., "Parking A-001") |
| `code` | varchar(20) | NOT NULL | | Short identifier (e.g., "A001") |
| `building` | varchar(100) | | | Building name |
| `floor` | varchar(20) | | | Floor number/name |
| `zone` | varchar(50) | | | Zone identifier (e.g., "North", "VIP") |
| `gps_latitude` | numeric(10,8) | | | Latitude (-90 to 90) |
| `gps_longitude` | numeric(11,8) | | | Longitude (-180 to 180) |
| `sensor_device_id` | uuid | | | **FK → sensor_devices.id** (assigned sensor) |
| `display_device_id` | uuid | | | **FK → display_devices.id** (assigned display) |
| `state` | varchar(20) | NOT NULL | `'FREE'` | Current state: FREE, OCCUPIED, RESERVED, MAINTENANCE |
| `metadata` | jsonb | | | Custom space metadata |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |
| `deleted_at` | timestamptz | | | Soft delete timestamp |

**Foreign Keys**:
- `site_id` → `sites.id` (ON DELETE RESTRICT)
- `sensor_device_id` → `sensor_devices.id` (ON DELETE NO ACTION)
- `display_device_id` → `display_devices.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Unique**: `(tenant_id, site_id, code)` WHERE `deleted_at IS NULL`
- **Check**: `state` IN ('FREE', 'OCCUPIED', 'RESERVED', 'MAINTENANCE')
- **Check**: GPS coordinates within valid ranges

**Indexes** (10 total):
- `idx_spaces_tenant` on `tenant_id` WHERE `deleted_at IS NULL`
- `idx_spaces_tenant_site` on `(tenant_id, site_id, code)` WHERE `deleted_at IS NULL`
- `idx_spaces_site` on `site_id` WHERE `deleted_at IS NULL`
- `idx_spaces_sensor_device` on `sensor_device_id`
- `idx_spaces_display_device` on `display_device_id`
- `idx_spaces_state` on `state` WHERE `deleted_at IS NULL`
- `idx_spaces_location` on `(building, floor, zone)` WHERE `deleted_at IS NULL`

**Referenced By**:
- `reservations.space_id`
- `sensor_readings.space_id`
- `actuations.space_id`
- `state_changes.space_id`
- `sensor_debounce_state.space_id` (ON DELETE CASCADE)
- `space_admin_overrides.space_id` (ON DELETE CASCADE)

**RLS Policy**:
```sql
POLICY "p_spaces_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid)
```

**Triggers**:
- `trg_spaces_sync_tenant_id` - Auto-syncs `tenant_id` from `site_id` on INSERT/UPDATE
- `update_spaces_updated_at` - Auto-updates `updated_at`

**Notes**:
- `tenant_id` is **auto-populated** from the parent site (you don't set it manually)
- Device assignment is tracked via **FK references only** (`sensor_device_id`, `display_device_id`)
- To get device EUIs, join with `sensor_devices` or `display_devices` tables
- Soft deletes via `deleted_at` preserve historical data

---

### `users`

**Purpose**: User accounts (can belong to multiple tenants via `user_memberships`).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `email` | varchar(255) | NOT NULL | | User email (unique, case-insensitive) |
| `name` | varchar(255) | NOT NULL | | User full name |
| `password_hash` | varchar(255) | NOT NULL | | bcrypt hash (12 rounds) |
| `metadata` | jsonb | | `'{}'` | Custom user metadata (phone, preferences) |
| `is_active` | boolean | | `true` | Active user flag |
| `email_verified` | boolean | | `false` | Email verification status |
| `is_platform_admin` | boolean | | `false` | Platform administrator flag (super-admin access) |
| `last_login_at` | timestamptz | | | Last login timestamp |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Constraints**:
- **PK**: `id`
- **Unique**: `lower(email)` (case-insensitive email uniqueness via `uq_users_email_ci`)

**Indexes**:
- `idx_users_email` on `email` WHERE `is_active = true`
- `idx_users_active` on `is_active`
- `idx_users_platform_admin` on `is_platform_admin` WHERE `is_platform_admin = true`

**Referenced By**:
- `user_memberships.user_id` (ON DELETE CASCADE)
- `refresh_tokens.user_id` (ON DELETE CASCADE)
- `display_policies.created_by` (ON DELETE NO ACTION)
- `space_admin_overrides.created_by` (ON DELETE NO ACTION)

**Triggers**:
- `update_users_updated_at` - Auto-updates `updated_at`

---

### `user_memberships`

**Purpose**: Maps users to tenants with roles (RBAC - Role-Based Access Control).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `user_id` | uuid | NOT NULL | | **FK → users.id** (ON DELETE CASCADE) |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `role` | varchar(20) | NOT NULL | | Role: platform_admin, owner, admin, operator, viewer |
| `metadata` | jsonb | | `'{}'` | Custom membership metadata |
| `is_active` | boolean | | `true` | Active membership flag |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Foreign Keys**:
- `user_id` → `users.id` (ON DELETE CASCADE)
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Unique**: `(user_id, tenant_id)` - one role per user per tenant
- **Check**: `role` IN ('platform_admin', 'owner', 'admin', 'operator', 'viewer')

**Indexes**:
- `idx_user_memberships_user` on `user_id` WHERE `is_active = true`
- `idx_user_memberships_user_active` on `(user_id, tenant_id)` WHERE `is_active = true`
- `idx_user_memberships_tenant` on `tenant_id` WHERE `is_active = true`
- `idx_user_memberships_tenant_active` on `(tenant_id, role, created_at DESC)` WHERE `is_active = true`
- `idx_user_memberships_role` on `(tenant_id, role)` WHERE `is_active = true`

**Role Hierarchy** (descending privilege):
1. **platform_admin** - Cross-tenant superuser (can access all tenants)
2. **owner** - Full tenant control (can delete tenant, manage all resources)
3. **admin** - Manage spaces, reservations, devices, API keys
4. **operator** - Create/update spaces and reservations
5. **viewer** - Read-only access to tenant resources

**Triggers**:
- `update_user_memberships_updated_at` - Auto-updates `updated_at`

---

## Device Tables

### `device_types`

**Purpose**: Catalog of supported device types and their capabilities.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `type_code` | varchar(100) | NOT NULL | | Unique device type identifier (e.g., "browan_tbms100_motion") |
| `type_name` | varchar(255) | NOT NULL | | Human-readable type name (e.g., "Browan TBMS100 Motion Sensor") |
| `category` | varchar(50) | NOT NULL | | Category: sensor, display, gateway |
| `manufacturer` | varchar(100) | | | Device manufacturer |
| `model_name` | varchar(100) | | | Model designation |
| `payload_decoder` | varchar(100) | | | Decoder function name for uplink parsing |
| `capabilities` | jsonb | NOT NULL | `'{}'` | Device capabilities (supported commands, sensors) |
| `is_active` | boolean | | `true` | Active device type flag |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Constraints**:
- **PK**: `id`
- **Unique**: `type_code`
- **Check**: `category` IN ('sensor', 'display', 'gateway')

**Referenced By**:
- `sensor_devices.device_type_id` (ON DELETE NO ACTION)
- `display_devices.device_type_id` (ON DELETE NO ACTION)

**Triggers**:
- `update_device_types_updated_at` - Auto-updates `updated_at`

---

### `sensor_devices`

**Purpose**: Registered sensor devices (auto-discovered from ChirpStack webhooks).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `dev_eui` | varchar(16) | NOT NULL | | Device EUI (**UPPERCASE** hex, 16 chars) |
| `device_type_id` | uuid | | | **FK → device_types.id** (ON DELETE NO ACTION) |
| `device_type` | varchar(50) | NOT NULL | | Legacy device type field |
| `device_model` | varchar(100) | | | Device model name |
| `manufacturer` | varchar(100) | | | Manufacturer name |
| `payload_decoder` | varchar(100) | | | Decoder function name |
| `status` | varchar(30) | | `'orphan'` | Status: orphan, active, inactive, decommissioned |
| `capabilities` | jsonb | | `'{}'` | Device capabilities |
| `enabled` | boolean | | `true` | Enabled flag |
| `last_seen_at` | timestamptz | | | Last uplink timestamp |
| `created_at` | timestamptz | | `now()` | Creation timestamp (first uplink) |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Foreign Keys**:
- `device_type_id` → `device_types.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Unique**: `dev_eui`
- **Check**: `dev_eui` matches `^[0-9A-F]{16}$` (UPPERCASE hex)
- **Check**: `status` IN ('orphan', 'active', 'inactive', 'decommissioned')

**Indexes**:
- `idx_sensor_devices_deveui` on `(dev_eui, enabled)` WHERE `enabled = true`
- `idx_sensor_devices_status` on `(status, created_at)`
- `idx_sensor_devices_type_id` on `device_type_id`

**Referenced By**:
- `spaces.sensor_device_id` (ON DELETE NO ACTION)

**Device Lifecycle**:
1. **orphan** - Auto-discovered from ChirpStack webhook, not assigned to any space
2. **active** - Assigned to a space via admin API (`POST /api/v1/admin/devices/sensor/{id}/assign`)
3. **inactive** - Unassigned from space (can be reassigned)
4. **decommissioned** - Permanently deactivated

**Triggers**:
- `trigger_sensor_devices_eui_uppercase` - Enforces UPPERCASE on `dev_eui`
- `update_sensor_devices_updated_at` - Auto-updates `updated_at`

---

### `display_devices`

**Purpose**: Registered display devices (LED indicators, e-ink signs).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `dev_eui` | varchar(16) | NOT NULL | | Device EUI (**UPPERCASE** hex, 16 chars) |
| `device_type_id` | uuid | | | **FK → device_types.id** (ON DELETE NO ACTION) |
| `device_type` | varchar(50) | NOT NULL | | Legacy device type field |
| `device_model` | varchar(100) | | | Device model name |
| `manufacturer` | varchar(100) | | | Manufacturer name |
| `status` | varchar(30) | | `'orphan'` | Status: orphan, active, inactive, decommissioned |
| `display_codes` | jsonb | NOT NULL | | Mapping: {state → hex payload} (e.g., {"free": "010000FF00"}) |
| `fport` | integer | | `1` | LoRaWAN fPort for downlinks |
| `confirmed_downlinks` | boolean | | `false` | Use confirmed downlinks (requires ACK) |
| `enabled` | boolean | | `true` | Enabled flag |
| `last_seen_at` | timestamptz | | | Last uplink timestamp |
| `created_at` | timestamptz | | `now()` | Creation timestamp (first uplink) |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Foreign Keys**:
- `device_type_id` → `device_types.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Unique**: `dev_eui`
- **Check**: `dev_eui` matches `^[0-9A-F]{16}$` (UPPERCASE hex)
- **Check**: `status` IN ('orphan', 'active', 'inactive', 'decommissioned')

**Indexes**:
- `idx_display_devices_deveui` on `(dev_eui, enabled)` WHERE `enabled = true`
- `idx_display_devices_status` on `(status, created_at)`
- `idx_display_devices_type_id` on `device_type_id`

**Referenced By**:
- `spaces.display_device_id` (ON DELETE NO ACTION)
- `actuations.display_device_id` (ON DELETE NO ACTION)

**Triggers**:
- `trigger_display_devices_eui_uppercase` - Enforces UPPERCASE on `dev_eui`
- `update_display_devices_updated_at` - Auto-updates `updated_at`

---

### `device_assignments`

**Purpose**: Audit trail for device assignment/unassignment events. Tracks when sensors and displays are assigned to spaces.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `space_id` | uuid | NOT NULL | | **FK → spaces.id** (ON DELETE CASCADE) |
| `device_type` | varchar(20) | NOT NULL | | Device type: sensor, display |
| `device_id` | uuid | NOT NULL | | Device UUID (references sensor_devices.id OR display_devices.id) |
| `device_eui` | varchar(16) | NOT NULL | | Denormalized device EUI (**UPPERCASE** hex) for quick reference |
| `assignment_type` | varchar(20) | NOT NULL | | Assignment type: assigned, unassigned, replaced |
| `assigned_at` | timestamptz | | `now()` | Assignment timestamp |
| `assigned_by` | uuid | | | **FK → users.id** (ON DELETE SET NULL) - user who performed the assignment |
| `notes` | text | | | Assignment notes/reason |
| `metadata` | jsonb | | `'{}'` | Custom assignment metadata |
| `tenant_id` | uuid | | | **FK → tenants.id** (auto-synced from space) |
| `created_at` | timestamptz | | `now()` | Creation timestamp |

**Foreign Keys**:
- `space_id` → `spaces.id` (ON DELETE CASCADE)
- `assigned_by` → `users.id` (ON DELETE SET NULL)
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Check**: `device_type` IN ('sensor', 'display')
- **Check**: `assignment_type` IN ('assigned', 'unassigned', 'replaced')

**Indexes**:
- `idx_device_assignments_space` on `(space_id, assigned_at DESC)`
- `idx_device_assignments_device` on `(device_type, device_id, assigned_at DESC)`
- `idx_device_assignments_eui` on `(device_eui, assigned_at DESC)`
- `idx_device_assignments_tenant` on `(tenant_id, assigned_at DESC)` WHERE `tenant_id IS NOT NULL`
- `idx_device_assignments_assigned_by` on `assigned_by` WHERE `assigned_by IS NOT NULL`

**RLS Policy**:
```sql
POLICY "p_device_assignments_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid OR is_platform_admin())
```

**Triggers**:
- `trg_device_assignments_sync_tenant` - Auto-syncs `tenant_id` from `space_id`
- `trigger_device_assignments_eui_uppercase` - Enforces UPPERCASE on `device_eui`

**Usage**:
- Automatically backfilled with existing device assignments during migration
- Use `log_device_assignment()` function to log new assignment events:
  ```sql
  SELECT log_device_assignment(
    p_space_id := '...',
    p_device_type := 'sensor',
    p_device_id := '...',
    p_device_eui := 'E8E1E1000103C3F8',
    p_assignment_type := 'assigned',
    p_assigned_by := '...',
    p_notes := 'Initial deployment'
  );
  ```

**Notes**:
- Provides complete audit trail of device movements between spaces
- Supports forensic analysis and debugging of device assignment issues
- `device_eui` is denormalized for performance (avoids JOINs in common queries)
- Assignment events are immutable (insert-only, no updates/deletes)

---

## Operational Tables

### `reservations`

**Purpose**: Parking space reservations with overlap prevention and idempotency.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `space_id` | uuid | NOT NULL | | **FK → spaces.id** (ON DELETE NO ACTION) |
| `request_id` | uuid | NOT NULL | `gen_random_uuid()` | Idempotency key (client-provided or auto-generated) |
| `start_time` | timestamptz | NOT NULL | | Reservation start time |
| `end_time` | timestamptz | NOT NULL | | Reservation end time |
| `status` | varchar(20) | NOT NULL | `'active'` | Status: pending, confirmed, cancelled, expired, active, completed, no_show |
| `user_email` | varchar(255) | | | Reserver email |
| `user_phone` | varchar(20) | | | Reserver phone |
| `metadata` | jsonb | | | Custom reservation metadata (vehicle info, payment details) |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Foreign Keys**:
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)
- `space_id` → `spaces.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Unique**: `(tenant_id, request_id)` WHERE `request_id IS NOT NULL` (idempotency)
- **EXCLUDE**: `(space_id WITH =, tstzrange(start_time, end_time, '[)') WITH &&)` WHERE `status` IN ('pending', 'confirmed')
  - **This prevents overlapping reservations at the database level**
- **Check**: `end_time > start_time`
- **Check**: `(end_time - start_time) <= '24:00:00'` (max 24-hour duration)
- **Check**: `status` IN ('pending', 'confirmed', 'cancelled', 'expired', 'active', 'completed', 'no_show')

**Indexes**:
- `idx_reservations_tenant_space` on `(tenant_id, space_id)`
- `idx_reservations_tenant_status_time` on `(tenant_id, status, start_time, end_time)` WHERE `status` IN ('pending', 'confirmed')
- `idx_reservations_space` on `space_id`
- `idx_reservations_space_overlap` on `(space_id, start_time, end_time)` WHERE `status` IN ('pending', 'confirmed')
- `idx_reservations_expiry` on `(end_time, status)` WHERE `status` IN ('pending', 'confirmed') - for expiry background job
- `idx_reservations_request_id` UNIQUE on `request_id`
- `idx_reservations_user_email` on `(user_email, start_time DESC)` WHERE `user_email IS NOT NULL`

**RLS Policy**:
```sql
POLICY "p_reservations_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid)
```

**Triggers**:
- `update_reservations_updated_at` - Auto-updates `updated_at`

**Key Features**:
- **Overlap Prevention**: PostgreSQL EXCLUDE constraint prevents double-booking even under high concurrency
- **Idempotency**: Same `request_id` returns existing reservation (safe retries)
- **Automatic Expiry**: Background job expires reservations after `end_time`

---

### `sensor_readings`

**Purpose**: Time-series sensor data from uplinks (deduplication via fcnt).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | bigint | NOT NULL | `nextval('sensor_readings_id_seq')` | Primary key (auto-increment) |
| `tenant_id` | uuid | | `'00000000-0000-0000-0000-000000000001'` | **FK → tenants.id** (auto-synced from space) |
| `device_eui` | varchar(16) | NOT NULL | | Sensor device EUI (**UPPERCASE** hex) |
| `space_id` | uuid | | | **FK → spaces.id** (NULL if device not assigned) |
| `fcnt` | integer | | | Frame counter (for deduplication) |
| `occupancy_state` | varchar(20) | | | Occupancy state: FREE, OCCUPIED |
| `battery` | numeric(5,2) | | | Battery voltage (e.g., 3.25V) |
| `temperature` | numeric(4,1) | | | Temperature (°C) |
| `rssi` | integer | | | Received signal strength indicator (dBm) |
| `snr` | numeric(4,1) | | | Signal-to-noise ratio (dB) |
| `timestamp` | timestamptz | | `now()` | Reading timestamp |

**Foreign Keys**:
- `space_id` → `spaces.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Unique**: `(tenant_id, device_eui, fcnt)` WHERE `fcnt IS NOT NULL` (fcnt deduplication)

**Indexes**:
- `idx_sensor_readings_tenant` on `(tenant_id, timestamp DESC)`
- `idx_sensor_readings_tenant_time` on `(tenant_id, timestamp DESC)` WHERE `tenant_id IS NOT NULL`
- `idx_sensor_readings_device_time` on `(device_eui, timestamp DESC)`
- `idx_sensor_readings_space_time` on `(space_id, timestamp DESC)` WHERE `space_id IS NOT NULL`
- `idx_sensor_readings_dedup` UNIQUE on `(tenant_id, device_eui, fcnt)` WHERE `fcnt IS NOT NULL`
- `idx_sensor_readings_timestamp_brin` **BRIN** on `timestamp` (efficient time-series index for large tables)

**RLS Policy**:
```sql
POLICY "p_sensor_readings_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid)
```

**Triggers**:
- `trg_sensor_readings_sync_tenant` - Auto-syncs `tenant_id` from `space_id`
- `trigger_sensor_readings_eui_uppercase` - Enforces UPPERCASE on `device_eui`

**Key Features**:
- **fcnt Deduplication**: Unique constraint prevents duplicate uplinks (ChirpStack may retry)
- **BRIN Index**: Efficient for time-series queries on large append-only tables
- **Tenant Isolation**: Auto-syncs `tenant_id` from assigned space

---

### `actuations`

**Purpose**: Downlink commands sent to display devices (audit trail).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | | | **FK → tenants.id** (auto-synced from space) |
| `space_id` | uuid | NOT NULL | | **FK → spaces.id** |
| `display_device_id` | uuid | | | **FK → display_devices.id** |
| `display_eui` | varchar(16) | NOT NULL | | Display device EUI (**UPPERCASE** hex) |
| `trigger_type` | varchar(30) | NOT NULL | | Trigger: sensor_uplink, api_reservation, manual_override, system_cleanup, reservation_expired |
| `trigger_source` | varchar(100) | | | Trigger source description |
| `previous_state` | varchar(20) | | | Previous space state |
| `new_state` | varchar(20) | NOT NULL | | New space state |
| `display_code` | varchar(20) | NOT NULL | | Display code sent (hex payload) |
| `fport` | integer | NOT NULL | | LoRaWAN fPort used |
| `confirmed` | boolean | | `false` | Use confirmed downlink (requires ACK) |
| `downlink_sent` | boolean | | `false` | Downlink successfully sent |
| `downlink_queue_id` | varchar(100) | | | ChirpStack downlink queue ID |
| `downlink_error` | text | | | Error message if failed |
| `response_time_ms` | integer | | | Downlink latency (milliseconds) - **SLO: p95 < 5s** |
| `retry_count` | integer | | `0` | Number of retries |
| `created_at` | timestamptz | | `now()` | Actuation created timestamp |
| `sent_at` | timestamptz | | | Downlink sent timestamp |
| `confirmed_at` | timestamptz | | | Downlink confirmed timestamp (if confirmed = true) |

**Foreign Keys**:
- `space_id` → `spaces.id` (ON DELETE NO ACTION)
- `display_device_id` → `display_devices.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Check**: `trigger_type` IN ('sensor_uplink', 'api_reservation', 'manual_override', 'system_cleanup', 'reservation_expired')

**Indexes**:
- `idx_actuations_tenant_space` on `(tenant_id, space_id, created_at DESC)` WHERE `tenant_id IS NOT NULL`
- `idx_actuations_space_time` on `(space_id, created_at DESC)`
- `idx_actuations_display_eui` on `(display_eui, created_at DESC)` WHERE `downlink_sent = true AND display_eui IS NOT NULL`
- `idx_actuations_trigger_type` on `(trigger_type, created_at DESC)`
- `idx_actuations_errors` on `(downlink_sent, downlink_error)` WHERE `downlink_sent = false OR downlink_error IS NOT NULL`
- `idx_actuations_created_at` on `created_at DESC`

**RLS Policy**:
```sql
POLICY "p_actuations_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid)
```

**Triggers**:
- `trg_actuations_sync_tenant` - Auto-syncs `tenant_id` from `space_id`
- `trigger_actuations_eui_uppercase` - Enforces UPPERCASE on `display_eui`

**Monitoring**:
- `response_time_ms` tracks end-to-end actuation latency (SLO: p95 < 5000ms)
- `downlink_error` captures failures for alerting
- `retry_count` tracks retry attempts (max 5 retries with exponential backoff)

---

### `state_changes`

**Purpose**: Audit trail of space state transitions.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | bigint | NOT NULL | `nextval('state_changes_id_seq')` | Primary key |
| `space_id` | uuid | NOT NULL | | **FK → spaces.id** |
| `previous_state` | varchar(20) | | | Previous state |
| `new_state` | varchar(20) | NOT NULL | | New state |
| `trigger_type` | varchar(30) | NOT NULL | | Trigger type |
| `trigger_source` | varchar(100) | | | Trigger source |
| `metadata` | jsonb | | | Change metadata (user, reason, etc.) |
| `timestamp` | timestamptz | | `now()` | Change timestamp |

**Foreign Keys**:
- `space_id` → `spaces.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`

**Indexes**:
- `idx_state_changes_space_time` on `(space_id, timestamp DESC)`
- `idx_state_changes_timestamp` on `timestamp DESC`

**Usage**: Historical audit trail for analytics and debugging.

---

## Policy & Control Tables

### `display_policies`

**Purpose**: Policy-driven display control per tenant.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `policy_name` | varchar(100) | NOT NULL | | Policy name (e.g., "Standard 3-Color") |
| `created_by` | uuid | | | **FK → users.id** |
| `is_active` | boolean | | `false` | Active policy flag (**only ONE active per tenant**) |
| `reserved_soon_threshold_sec` | integer | | `900` | "Reserved Soon" threshold (seconds, default 15 min) |
| `sensor_stale_threshold_sec` | integer | | `60` | Sensor data staleness threshold (seconds) |
| `sensor_debounce_threshold_sec` | integer | | `10` | Sensor debounce threshold (seconds) |
| `free_color` | varchar(6) | | `'00FF00'` | FREE state color (hex RGB) |
| `occupied_color` | varchar(6) | | `'FF0000'` | OCCUPIED state color (hex RGB) |
| `reserved_color` | varchar(6) | | `'0000FF'` | RESERVED state color (hex RGB) |
| `reserved_soon_color` | varchar(6) | | `'FFFF00'` | RESERVED SOON state color (hex RGB) |
| `out_of_service_color` | varchar(6) | | `'808080'` | OUT OF SERVICE state color (hex RGB) |
| `blocked_color` | varchar(6) | | `'800080'` | BLOCKED state color (hex RGB) |
| `blink_reserved_soon` | boolean | | `false` | Blink display for "reserved soon" |
| `blink_interval_ms` | integer | | `500` | Blink interval (milliseconds) |
| `blink_enabled` | boolean | | `true` | Global blink enable flag |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | | Last update timestamp |
| `description` | text | | | Policy description |

**Foreign Keys**:
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)
- `created_by` → `users.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Partial Unique**: `tenant_id` WHERE `is_active = true` (only ONE active policy per tenant)

**Indexes**:
- `idx_display_policies_tenant` on `(tenant_id, is_active)`
- `idx_display_policies_active` UNIQUE on `tenant_id` WHERE `is_active = true`

**Key Features**:
- Policy changes invalidate Redis cache for display states
- Supports time-based thresholds and color customization per tenant

---

### `sensor_debounce_state`

**Purpose**: Debounce sensor state changes to prevent flapping.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `space_id` | uuid | NOT NULL | | **FK → spaces.id** (ON DELETE CASCADE) |
| `current_state` | varchar(20) | NOT NULL | | Current debounced state: FREE, OCCUPIED |
| `last_state_change_at` | timestamptz | NOT NULL | `now()` | Last state change timestamp |
| `last_uplink_at` | timestamptz | NOT NULL | `now()` | Last sensor uplink timestamp |
| `uplink_count` | integer | | `0` | Total uplink count |
| `metadata` | jsonb | | `'{}'` | Debounce metadata |

**Foreign Keys**:
- `space_id` → `spaces.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Unique**: `space_id`
- **Check**: `current_state` IN ('FREE', 'OCCUPIED')

**Indexes**:
- `idx_sensor_debounce_space` UNIQUE on `space_id`
- `idx_sensor_debounce_stale` on `last_uplink_at` (for staleness detection)

**Usage**: Prevents rapid state changes from triggering multiple actuations.

---

### `space_admin_overrides`

**Purpose**: Admin overrides for space state (maintenance, blocked).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `space_id` | uuid | NOT NULL | | **FK → spaces.id** (ON DELETE CASCADE) |
| `override_type` | varchar(30) | NOT NULL | | Type: out_of_service, blocked |
| `reason` | text | | | Override reason |
| `created_by` | uuid | | | **FK → users.id** |
| `is_active` | boolean | | `true` | Active override flag |
| `start_time` | timestamptz | NOT NULL | `now()` | Override start time |
| `end_time` | timestamptz | | | Override end time (NULL = indefinite) |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `updated_at` | timestamptz | | `now()` | Last update timestamp |

**Foreign Keys**:
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)
- `space_id` → `spaces.id` (ON DELETE CASCADE)
- `created_by` → `users.id` (ON DELETE NO ACTION)

**Constraints**:
- **PK**: `id`
- **Check**: `override_type` IN ('out_of_service', 'blocked')
- **Check**: `end_time IS NULL OR end_time > start_time`

**Indexes**:
- `idx_space_admin_overrides_space` on `(space_id, is_active, start_time, end_time)`
- `idx_space_admin_overrides_active` on `(space_id, override_type, is_active)` WHERE `is_active = true`
- `idx_space_admin_overrides_tenant` on `(tenant_id, is_active)`

**Priority** (used by `compute_display_state()` function):
1. **Priority 1**: `out_of_service` - displays gray
2. **Priority 2**: `blocked` - displays purple
3. (Lower priorities: reservations, sensor state)

---

## Authentication Tables

### `api_keys`

**Purpose**: API key authentication for service accounts.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `key_hash` | varchar(255) | NOT NULL | | bcrypt hash of API key |
| `key_name` | varchar(100) | | | API key name/description |
| `scopes` | text[] | NOT NULL | `ARRAY['spaces:read', 'devices:read']` | API key scopes (array) |
| `is_admin` | boolean | | `false` | Admin API key flag (cross-tenant access) |
| `is_active` | boolean | | `true` | Active API key flag |
| `last_used_at` | timestamptz | | | Last usage timestamp |
| `created_at` | timestamptz | | `now()` | Creation timestamp |

**Foreign Keys**:
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Unique**: `key_hash`

**Indexes**:
- `idx_api_keys_tenant` on `tenant_id` WHERE `is_active = true`
- `idx_api_keys_active` on `is_active` WHERE `is_active = true`
- `idx_api_keys_admin` on `is_admin` WHERE `is_active = true AND is_admin = true`
- `idx_api_keys_scopes` **GIN** on `scopes` (array search)
- `idx_api_keys_last_used` on `last_used_at DESC` WHERE `is_active = true`

**RLS Policy**:
```sql
POLICY "p_api_keys_tenant"
  USING (tenant_id = current_setting('app.current_tenant')::uuid)
```

**Scopes** (least-privilege access control):
- `spaces:read`, `spaces:write`
- `devices:read`, `devices:write`
- `reservations:read`, `reservations:write`
- `admin:*` - Full tenant admin access

---

### `refresh_tokens`

**Purpose**: JWT refresh tokens for session management.

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | integer | NOT NULL | `nextval('refresh_tokens_id_seq')` | Primary key |
| `user_id` | uuid | NOT NULL | | **FK → users.id** (ON DELETE CASCADE) |
| `token_hash` | varchar(255) | NOT NULL | | SHA-256 hash of refresh token |
| `device_fingerprint` | varchar(255) | | | Device identifier (IP + user agent hash) |
| `is_active` | boolean | | `true` | Active token flag |
| `expires_at` | timestamptz | NOT NULL | | Token expiry (default: 30 days) |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `last_used_at` | timestamptz | | | Last usage timestamp |

**Foreign Keys**:
- `user_id` → `users.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Unique**: `token_hash`

**Indexes**:
- `idx_refresh_tokens_user` on `(user_id, is_active, expires_at)`
- `idx_refresh_tokens_hash` UNIQUE on `token_hash`
- `idx_refresh_tokens_expiry` on `expires_at` WHERE `is_active = true`

**Security**:
- Tokens stored as SHA-256 hashes (never plaintext)
- Device fingerprinting prevents token theft
- 30-day expiry (configurable)

---

### `webhook_secrets`

**Purpose**: Per-tenant webhook signing keys (HMAC-SHA256).

**Columns**:
| Column | Type | Nullable | Default | Description |
|--------|------|----------|---------|-------------|
| `id` | uuid | NOT NULL | `gen_random_uuid()` | Primary key |
| `tenant_id` | uuid | NOT NULL | | **FK → tenants.id** (ON DELETE CASCADE) |
| `webhook_type` | varchar(50) | NOT NULL | | Webhook type: chirpstack, external |
| `secret_key` | varchar(255) | NOT NULL | | HMAC signing secret |
| `is_active` | boolean | | `true` | Active secret flag |
| `created_at` | timestamptz | | `now()` | Creation timestamp |
| `last_used_at` | timestamptz | | | Last usage timestamp |

**Foreign Keys**:
- `tenant_id` → `tenants.id` (ON DELETE CASCADE)

**Constraints**:
- **PK**: `id`
- **Unique**: `(tenant_id, webhook_type)` WHERE `is_active = true`

**Indexes**:
- `idx_webhook_secrets_tenant` on `(tenant_id, webhook_type, is_active)`

**Usage**: ChirpStack webhooks validate using HMAC-SHA256 signature.

---

## Foreign Key Relationships

**Summary of all 26 unique FK relationships**:

| From Table | Column | → To Table | Column | ON DELETE |
|------------|--------|-----------|--------|-----------|
| `actuations` | `display_device_id` | → `display_devices` | `id` | NO ACTION |
| `actuations` | `space_id` | → `spaces` | `id` | NO ACTION |
| `api_keys` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `device_assignments` | `assigned_by` | → `users` | `id` | SET NULL |
| `device_assignments` | `space_id` | → `spaces` | `id` | CASCADE |
| `device_assignments` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `display_devices` | `device_type_id` | → `device_types` | `id` | NO ACTION |
| `display_policies` | `created_by` | → `users` | `id` | NO ACTION |
| `display_policies` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `refresh_tokens` | `user_id` | → `users` | `id` | CASCADE |
| `reservations` | `space_id` | → `spaces` | `id` | NO ACTION |
| `reservations` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `sensor_debounce_state` | `space_id` | → `spaces` | `id` | CASCADE |
| `sensor_devices` | `device_type_id` | → `device_types` | `id` | NO ACTION |
| `sensor_readings` | `space_id` | → `spaces` | `id` | NO ACTION |
| `sites` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `space_admin_overrides` | `created_by` | → `users` | `id` | NO ACTION |
| `space_admin_overrides` | `space_id` | → `spaces` | `id` | CASCADE |
| `space_admin_overrides` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `spaces` | `display_device_id` | → `display_devices` | `id` | NO ACTION |
| `spaces` | `sensor_device_id` | → `sensor_devices` | `id` | NO ACTION |
| `spaces` | `site_id` | → `sites` | `id` | **RESTRICT** |
| `state_changes` | `space_id` | → `spaces` | `id` | NO ACTION |
| `user_memberships` | `tenant_id` | → `tenants` | `id` | CASCADE |
| `user_memberships` | `user_id` | → `users` | `id` | CASCADE |
| `webhook_secrets` | `tenant_id` | → `tenants` | `id` | CASCADE |

**Key Observations**:

1. **Tenant hierarchy enforced via CASCADE**:
   - Delete tenant → deletes sites, user_memberships, api_keys, reservations, policies

2. **Sites protected by RESTRICT**:
   - Cannot delete site if it has active spaces (must delete spaces first)

3. **Spaces use NO ACTION**:
   - Prevents accidental data loss (reservations, readings, actuations preserved)

4. **Devices use NO ACTION**:
   - Unassigning device from space doesn't delete historical data

---

## Indexes & Performance

**Total Indexes**: 80+ across all tables

**Key Index Types**:

1. **B-Tree Indexes** (default):
   - Primary keys, foreign keys, unique constraints
   - Most WHERE clause columns

2. **BRIN Indexes** (Block Range INdexes):
   - `sensor_readings.timestamp` - efficient for time-series data
   - Minimal storage overhead, fast for range queries on append-only tables

3. **GIN Indexes** (Generalized Inverted Index):
   - `api_keys.scopes` - fast array membership queries

4. **Partial Indexes** (WHERE clauses):
   - Example: `idx_spaces_tenant` WHERE `deleted_at IS NULL`
   - Smaller index size, faster queries on active records only

5. **Composite Indexes**:
   - Example: `(tenant_id, site_id, code)` for multi-column queries

**Performance Considerations**:
- BRIN indexes save ~95% storage vs B-Tree for time-series data
- Partial indexes reduce index size by 50-80% for soft-deleted tables
- GIN indexes enable fast `ANY(array)` queries on scopes

---

## Row-Level Security (RLS)

**Enabled on**:
- `tenants`, `sites`, `spaces`, `reservations`, `sensor_readings`, `actuations`, `api_keys`, `device_assignments`

**How it works**:

```sql
-- Application sets tenant context and current user
SET app.current_tenant = '550e8400-e29b-41d4-a716-446655440000';
SET app.current_user = 'user-uuid-here';

-- All queries automatically filtered by tenant (unless user is platform admin)
SELECT * FROM spaces;
-- Translates to: SELECT * FROM spaces WHERE tenant_id = '550e8400-e29b-41d4-a716-446655440000';
```

**Benefits**:
- **Defense in depth**: Even if application forgets to filter by `tenant_id`, database enforces isolation
- **Prevents cross-tenant data leaks**: Impossible to access other tenant's data
- **Simplified queries**: No need to add `WHERE tenant_id = ?` everywhere
- **Platform admin support**: Super-admins automatically bypass tenant isolation

**Platform Admin Bypass**:

Platform administrators (users with `is_platform_admin = true`) can access **all tenants** automatically:

```sql
-- Method 1: Platform admin flag (recommended, added in v5.3.1)
UPDATE users SET is_platform_admin = true WHERE email = 'admin@verdegris.io';
SET app.current_user = '<admin-user-uuid>';
-- Now this user can see all tenants automatically

-- Method 2: Legacy bypass (still supported)
SET app.current_tenant = NULL;  -- Bypass RLS entirely (requires superuser)
```

**RLS Policy Example** (with platform admin support):
```sql
CREATE POLICY p_spaces_tenant ON spaces
  FOR ALL
  USING (
    tenant_id = current_setting('app.current_tenant', true)::uuid
    OR is_platform_admin()  -- Platform admins bypass tenant filter
  );
```

**Helper Functions**:
- `is_platform_admin()` - Returns true if `app.current_user` is a platform admin

---

## Triggers & Functions

### Auto-Update Timestamps

```sql
CREATE FUNCTION update_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END$$ LANGUAGE plpgsql;
```

**Applied to**: `tenants`, `sites`, `spaces`, `users`, `user_memberships`, `reservations`, `sensor_devices`, `display_devices`

---

### EUI Normalization (UPPERCASE)

```sql
CREATE FUNCTION enforce_eui_uppercase() RETURNS trigger AS $$
BEGIN
  CASE TG_TABLE_NAME
    WHEN 'sensor_devices' THEN
      NEW.dev_eui := UPPER(NEW.dev_eui);
    WHEN 'display_devices' THEN
      NEW.dev_eui := UPPER(NEW.dev_eui);
    WHEN 'sensor_readings' THEN
      NEW.device_eui := UPPER(NEW.device_eui);
    WHEN 'actuations' THEN
      NEW.display_eui := UPPER(NEW.display_eui);
    WHEN 'device_assignments' THEN
      NEW.device_eui := UPPER(NEW.device_eui);
  END CASE;
  RETURN NEW;
END$$ LANGUAGE plpgsql;
```

**Why**: ChirpStack sends lowercase EUIs (`e8e1e1000103c3f8`), we normalize to UPPERCASE (`E8E1E1000103C3F8`) for consistency.

**Applied to**: `sensor_devices`, `display_devices`, `sensor_readings`, `actuations`, `device_assignments`

**Note**: As of v5.3.1, the `spaces` table no longer has `sensor_eui` and `display_eui` columns. Device EUIs are obtained by joining with device tables.

---

### Tenant ID Auto-Sync

```sql
CREATE FUNCTION spaces_sync_tenant_id() RETURNS trigger AS $$
BEGIN
  IF NEW.site_id IS NOT NULL THEN
    SELECT s.tenant_id INTO NEW.tenant_id
    FROM sites s
    WHERE s.id = NEW.site_id;
  END IF;
  RETURN NEW;
END$$ LANGUAGE plpgsql;
```

**Purpose**: Auto-populates `spaces.tenant_id` from parent site (ensures consistency).

---

### Display State Computation

```sql
CREATE FUNCTION compute_display_state(p_space_id uuid, p_tenant_id uuid)
RETURNS TABLE(display_state varchar, display_color varchar, display_blink boolean, priority_level integer, reason text)
```

**Priority Order** (highest to lowest):
1. **Admin Override: out_of_service** → MAINTENANCE (gray)
2. **Admin Override: blocked** → MAINTENANCE (purple)
3. **Active Reservation (now)** → RESERVED (blue)
4. **Upcoming Reservation (soon)** → RESERVED (yellow, blink)
5. **Sensor State (recent)** → FREE/OCCUPIED (green/red)
6. **Default** → FREE (green)

---

## Database Maintenance

### Backup

```bash
# Full backup
docker exec parking-postgres pg_dump -U parking_user -d parking_v5 --format=custom -f /tmp/parking_v5.dump

# Schema only
docker exec parking-postgres pg_dump -U parking_user -d parking_v5 --schema-only > parking_v5_schema.sql
```

### Monitoring

```sql
-- Database size
SELECT pg_size_pretty(pg_database_size('parking_v5'));

-- Table sizes
SELECT
  tablename,
  pg_size_pretty(pg_total_relation_size('public.' || tablename)) AS size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size('public.' || tablename) DESC;

-- Index usage
SELECT
  tablename,
  indexname,
  idx_scan,
  pg_size_pretty(pg_relation_size(indexrelid::regclass)) AS index_size
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;
```

---

**Last Updated**: 2025-10-25
**Schema Version**: V5.4.0 (Multi-Tenancy + Production Hardening + Loose Coupling)
**Migration**: 012_schema_improvements_v5_3.sql
**Maintained By**: Verdegris Engineering Team
**Next Review**: 2026-01-25

**Recent Changes** (V5.4.0):
1. ✅ Removed redundant EUI columns from `spaces` table (`sensor_eui`, `display_eui`)
2. ✅ Added `is_platform_admin` flag to `users` table for super-admin access
3. ✅ Updated all RLS policies to support platform admin bypass via `is_platform_admin()`
4. ✅ Created `device_assignments` audit table to track device assignment history
5. ✅ Added `log_device_assignment()` helper function for logging assignment events
6. ✅ EUI case sensitivity enforcement - all EUIs stored as UPPERCASE via database triggers
7. ✅ Fixed reservation display state calculation using effective_state logic
8. ✅ Platform admin tenant switching with full context preservation
