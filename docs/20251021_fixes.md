---

# **A) Critical fixes (do these first)**

1. **Name collision:** **orphan_devices** **table vs view**
  
  You canâ€™t have both. Rename the view to v_orphan_devices (or vw_orphan_devices) everywhere you reference it.
  
2. **Reservation statuses are inconsistent**
  

- Table spec uses: pending | confirmed | expired | cancelled
  
- Later â€œEnums & Valid Valuesâ€ says: active | completed | cancelled | no_show
  
- Indexing section mentions status = 'active'.
  
  ðŸ‘‰ Pick **one set** (I recommend the tableâ€™s set) and update docs + partial indexes accordingly.
  

3. **Case-insensitive email uniqueness isnâ€™t enforced**
  
  You list UNIQUE (email) but call it â€œcase-insensitiveâ€. In Postgres thatâ€™s not CI. Use a **unique index on** **lower(email)** and drop the table-level unique.
  
4. **RLS is claimed but not defined**
  
  You say â€œstrict tenant isolation via FKâ€; thatâ€™s not isolation. Add **Row-Level Security** with current_setting('app.current_tenant'). (Patch below.)
  
5. **Idempotency is documented but not enforced**
  
  Add **unique (tenant_id, request_id) where request_id is not null** on reservations.
  
6. **Downlink/display field naming drift**
  
  You use display_eui most places, but actuations has display_deveui. Standardize to **display_eui**.
  
7. **sensor_readings** **dedup + tenancy missing**
  
  Doc talks about FCnt de-dup, but the table has **no** **fcnt** (nor tenant_id). Add both, then enforce unique (tenant_id, device_eui, fcnt) for idempotent ingest. (Patch below.)
  
8. **Display uniqueness in spaces**
  
  You made sensor_eui unique; do the same for **display_eui** (unique where not null, and ideally where deleted_at is null).
  
9. **UUID extension mismatch**
  
  You default to gen_random_uuid() (thatâ€™s **pgcrypto**), but you also list uuid-ossp. If you keep gen_random_uuid(), you donâ€™t need uuid-ossp. (Or switch defaults to uuid_generate_v4().)
  
10. **Materialized view + multi-tenant risk**
  
  v_spaces materializes *all* tenants. Anyone with SELECT on it can see cross-tenant data regardless of RLS on base tables. Lock it down via privileges, or replace with a secure view (non-materialized) that filters by current_setting('app.current_tenant').
  
11. **Retention policy contradiction**
  
  Background tasks say â€œpurge old sensor_readings (>30 days)â€, but later you say â€œretained indefinitelyâ€. Decide policy (I suggest partition + retention window) and make both sections agree.
  

---

# **B) Strong improvements (next sprint)**

- **Add** **tenant_id** **to all tenant-scoped operational tables** (sensor_readings, state_changes, actuations) + triggers to sync from space_id. This makes RLS fast and simple (no join in policies).
  
- **CHECK constraints for EUI formatting**
  
  Enforce hex and length once (and normalize to uppercase on write). This prevents subtle join/index misses.
  
- **Partial uniques & partial indexes**
  
  Keep indexes tiny and relevant (e.g., UNIQUE(display_eui) WHERE display_eui IS NOT NULL AND deleted_at IS NULL).
  
- **Typed enums**
  
  Replace varchar status fields with Postgres ENUM types to avoid drift and typos.
  
- **Time-series partitioning**
  
  Convert sensor_readings (and later actuations) to monthly partitions now; add a small retention worker. BRIN stays great on each child.
  
- **Deprecate** **api_keys.is_admin**
  
  You already have scopes text[]. Prefer scopes only; if you keep the flag temporarily, add a CHECK that it implies 'admin' âˆˆ scopes.
  
- **FK ON DELETE behavior**
  
  Consider spaces.(sensor_device_id|display_device_id) ON DELETE SET NULL so decommissioning a device doesnâ€™t require deleting spaces.
  
- **Materialized view safety**
  
  If you must keep v_spaces as MV, **do not grant** global SELECT; expose tenant views/APIs that always filter by tenant.
  

---

# **C) â€œPatch packâ€ â€” copy/paste SQL**

> Tweak names to your liking; this assumes Postgres 16 and pgcrypto loaded.

```
-- 0) Extensions: keep pgcrypto (gen_random_uuid), drop uuid-ossp if unused
-- CREATE EXTENSION IF NOT EXISTS pgcrypto;
-- DROP EXTENSION IF EXISTS "uuid-ossp";

-- 1) Fix email uniqueness (case-insensitive)
-- (a) drop the table-level UNIQUE if present
ALTER TABLE users DROP CONSTRAINT IF EXISTS users_email_key;
-- (b) enforce CI uniqueness
CREATE UNIQUE INDEX IF NOT EXISTS uq_users_email_ci ON users (lower(email));

-- 2) Unify actuation naming
ALTER TABLE actuations RENAME COLUMN display_deveui TO display_eui;

-- 3) Display uniqueness in spaces (mirror sensor_eui)
CREATE UNIQUE INDEX IF NOT EXISTS uq_spaces_display_eui
  ON spaces(display_eui)
  WHERE display_eui IS NOT NULL AND deleted_at IS NULL;

-- 4) Reservation idempotency (per-tenant)
CREATE UNIQUE INDEX IF NOT EXISTS uq_reservations_request
  ON reservations(tenant_id, request_id)
  WHERE request_id IS NOT NULL;

-- 5) Reservations: EXCLUDE uses only allowed statuses (keep your set)
-- Ensure btree_gist is present
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- Optional: re-create with name for clarity
ALTER TABLE reservations DROP CONSTRAINT IF EXISTS uq_reservations_no_overlap;
ALTER TABLE reservations
  ADD CONSTRAINT uq_reservations_no_overlap
  EXCLUDE USING gist (
    space_id WITH =,
    tstzrange(start_time, end_time) WITH &&
  )
  WHERE (status IN ('pending','confirmed'));

-- 6) Add FCnt + tenant_id to sensor_readings for dedup + RLS
ALTER TABLE sensor_readings
  ADD COLUMN IF NOT EXISTS tenant_id uuid,
  ADD COLUMN IF NOT EXISTS fcnt integer;

-- Keep tenant_id synced from the space when present
CREATE OR REPLACE FUNCTION sensor_readings_sync_tenant_id()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.space_id IS NOT NULL THEN
    SELECT s.tenant_id INTO NEW.tenant_id FROM spaces s WHERE s.id = NEW.space_id;
  END IF;
  RETURN NEW;
END$$;

DROP TRIGGER IF EXISTS trg_sensor_readings_sync_tenant ON sensor_readings;
CREATE TRIGGER trg_sensor_readings_sync_tenant
  BEFORE INSERT OR UPDATE OF space_id
  ON sensor_readings
  FOR EACH ROW
  EXECUTE FUNCTION sensor_readings_sync_tenant_id();

-- De-dup per device per tenant on FCnt (optional: add WHERE fcnt IS NOT NULL)
CREATE UNIQUE INDEX IF NOT EXISTS uq_readings_device_fcnt
  ON sensor_readings(tenant_id, device_eui, fcnt)
  WHERE fcnt IS NOT NULL;

-- 7) Normalize EUIs and enforce hex/length
-- Uppercase on write
CREATE OR REPLACE FUNCTION enforce_eui_upper()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.dev_eui IS NOT NULL THEN NEW.dev_eui := upper(NEW.dev_eui); END IF;
  IF TG_TABLE_NAME = 'spaces' THEN
    IF NEW.sensor_eui  IS NOT NULL THEN NEW.sensor_eui  := upper(NEW.sensor_eui); END IF;
    IF NEW.display_eui IS NOT NULL THEN NEW.display_eui := upper(NEW.display_eui); END IF;
  END IF;
  RETURN NEW;
END$$;

-- Apply to device registries and spaces
DROP TRIGGER IF EXISTS trg_sensor_eui_upper ON sensor_devices;
CREATE TRIGGER trg_sensor_eui_upper BEFORE INSERT OR UPDATE ON sensor_devices
FOR EACH ROW EXECUTE FUNCTION enforce_eui_upper();

DROP TRIGGER IF EXISTS trg_display_eui_upper ON display_devices;
CREATE TRIGGER trg_display_eui_upper BEFORE INSERT OR UPDATE ON display_devices
FOR EACH ROW EXECUTE FUNCTION enforce_eui_upper();

DROP TRIGGER IF EXISTS trg_spaces_eui_upper ON spaces;
CREATE TRIGGER trg_spaces_eui_upper BEFORE INSERT OR UPDATE ON spaces
FOR EACH ROW EXECUTE FUNCTION enforce_eui_upper();

-- CHECK constraints for hex (16 chars)
ALTER TABLE sensor_devices  DROP CONSTRAINT IF EXISTS chk_sensor_dev_eui_hex;
ALTER TABLE display_devices DROP CONSTRAINT IF EXISTS chk_display_dev_eui_hex;
ALTER TABLE spaces         DROP CONSTRAINT IF EXISTS chk_spaces_eui_hex;

ALTER TABLE sensor_devices
  ADD CONSTRAINT chk_sensor_dev_eui_hex
  CHECK (dev_eui ~ '^[0-9A-F]{16}$');

ALTER TABLE display_devices
  ADD CONSTRAINT chk_display_dev_eui_hex
  CHECK (dev_eui ~ '^[0-9A-F]{16}$');

ALTER TABLE spaces
  ADD CONSTRAINT chk_spaces_eui_hex
  CHECK (
    (sensor_eui  IS NULL OR sensor_eui  ~ '^[0-9A-F]{16}$') AND
    (display_eui IS NULL OR display_eui ~ '^[0-9A-F]{16}$')
  );

-- 8) Row-Level Security: enable + policies (pattern)
-- Use a single setting: app.current_tenant::uuid
DO $$
BEGIN
  PERFORM set_config('app.current_tenant','00000000-0000-0000-0000-000000000000', true);
EXCEPTION WHEN OTHERS THEN
  -- ignore, just ensures the setting exists
END$$;

-- Helper to create a standard policy on a tenant table
-- Example for 'spaces' (has tenant_id)
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;
ALTER TABLE spaces FORCE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS p_spaces_tenant ON spaces;
CREATE POLICY p_spaces_tenant ON spaces
  USING (tenant_id = current_setting('app.current_tenant', true)::uuid)
  WITH CHECK (tenant_id = current_setting('app.current_tenant', true)::uuid);

-- Repeat for other tenant tables:
-- sites, sensor_devices (if you add tenant_id), display_devices (if you add tenant_id),
-- reservations, api_keys, webhook_secrets, orphan_devices, actuations, sensor_readings, state_changes, etc.

-- 9) Rename the conflicting view
DROP VIEW IF EXISTS orphan_devices; -- if it was a view
-- Recreate as v_orphan_devices (definition omitted here)
-- CREATE VIEW v_orphan_devices AS ...;
```

> If you keep v_spaces as a materialized view, do **not** grant SELECT broadly:

```
REVOKE ALL ON MATERIALIZED VIEW v_spaces FROM PUBLIC;
-- Grant only to the backend role that always sets app.current_tenant and post-filters.
```

---

##