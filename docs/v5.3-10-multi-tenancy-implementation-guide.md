# Multi-Tenancy & RBAC Implementation Guide

**Status:** Core implementation complete ✅
**Date:** 2025-10-19
**Version:** v5.3

## Overview

This document describes the multi-tenancy and RBAC (Role-Based Access Control) implementation for the Smart Parking Platform v5.3. The implementation provides strict tenant isolation, user management, and role-based permissions.

---

## What Has Been Implemented

### 1. Database Schema (✅ Complete)

**File:** `migrations/002_multi_tenancy_rbac.sql`

**New Tables:**
- **`tenants`** - Organizations with data isolation
- **`sites`** - Physical locations within a tenant (multi-site support)
- **`users`** - User accounts for authentication
- **`user_memberships`** - Links users to tenants with roles

**Updated Tables:**
- **`api_keys`** - Now includes `tenant_id` FK
- **`spaces`** - Now includes `site_id` and denormalized `tenant_id`

**Views:**
- `tenant_summary` - Tenant statistics
- `user_permissions` - User access matrix
- `site_details` - Site occupancy info

**Key Features:**
- Tenant isolation enforced at database level
- Cascade deletes to maintain referential integrity
- Denormalized `tenant_id` in spaces for fast lookups
- Backward compatibility with default tenant/site

### 2. Data Models (✅ Complete)

**File:** `src/models.py`

**New Models:**
- `UserRole` enum (owner, admin, operator, viewer)
- `Tenant`, `TenantCreate`, `TenantUpdate`
- `Site`, `SiteCreate`, `SiteUpdate`
- `User`, `UserCreate`, `UserUpdate`, `UserPasswordUpdate`
- `UserMembership`, `UserMembershipCreate`, `UserMembershipUpdate`
- `TenantContext` - Current authenticated tenant context
- `LoginRequest`, `LoginResponse`, `TokenData`
- `APIKeyCreate`, `APIKeyResponse`, `APIKey`

**Updated Models:**
- `Space` now includes `site_id` and `tenant_id`
- `SpaceCreate` requires `site_id`

### 3. Authentication & Authorization (✅ Complete)

**File:** `src/tenant_auth.py`

**Features Implemented:**
- **JWT Token Management**
  - `create_access_token()` - Generate JWT tokens
  - `decode_access_token()` - Validate and decode tokens
  - 24-hour token expiry

- **Password Hashing**
  - bcrypt hashing for user passwords
  - `hash_password()`, `verify_password()`

- **Tenant Resolution**
  - `resolve_tenant_from_api_key()` - API key → tenant context
  - `resolve_tenant_from_jwt()` - JWT → tenant context
  - Validates tenant/user/membership is active

- **FastAPI Dependencies**
  - `get_current_tenant()` - Resolve tenant from JWT or API key
  - `get_optional_tenant()` - Optional authentication
  - `require_role(role)` - RBAC dependency factory
  - `require_owner`, `require_admin`, `require_operator`, `require_viewer`

**Authentication Flow:**
1. Check for JWT Bearer token first
2. Fall back to X-API-Key header
3. Resolve tenant context from either
4. Verify tenant/user/membership is active
5. Attach context to request state

### 4. Rate Limiting (✅ Complete)

**File:** `src/rate_limit.py`

**Features Added:**
- `TenantRateLimitConfig` - Per-tenant rate limits
- `check_tenant_rate_limit()` - Tenant-specific rate limiting
- Supports: webhook QPS, downlink ops/min, reservation attempts/min

**Configuration:**
```python
TenantRateLimitConfig(
    webhook_qps=10,
    downlink_ops_per_minute=100,
    reservation_attempts_per_minute=50
)
```

### 5. API Endpoints (✅ Complete)

**File:** `src/api_tenants.py`

**Authentication Endpoints:**
- `POST /api/v1/auth/login` - User login with JWT
- `POST /api/v1/auth/register` - Register user + create tenant

**Tenant Management:**
- `GET /api/v1/tenants/current` - Get current tenant info
- `PATCH /api/v1/tenants/current` - Update tenant (OWNER only)

**Site Management:**
- `GET /api/v1/sites` - List sites
- `POST /api/v1/sites` - Create site (ADMIN+)
- `GET /api/v1/sites/{site_id}` - Get site
- `PATCH /api/v1/sites/{site_id}` - Update site (ADMIN+)

**User Management:**
- `GET /api/v1/users` - List tenant users (ADMIN+)

**API Key Management:**
- `GET /api/v1/api-keys` - List API keys (OWNER only)
- `POST /api/v1/api-keys` - Create API key (OWNER only)
- `DELETE /api/v1/api-keys/{key_id}` - Revoke API key (OWNER only)

---

## RBAC Role Hierarchy

```
VIEWER < OPERATOR < ADMIN < OWNER
```

**Role Permissions:**

| Role | Permissions |
|------|-------------|
| **VIEWER** | Read-only access to spaces, reservations, telemetry |
| **OPERATOR** | VIEWER + manage reservations, view telemetry, trigger displays |
| **ADMIN** | OPERATOR + manage sites, spaces, devices, users (not billing) |
| **OWNER** | ADMIN + manage billing, API keys, tenant settings |

**API Keys:**
- API keys have implicit ADMIN-level access
- Used for service-to-service authentication
- No user context (suitable for webhooks, integrations)

---

## How to Complete the Implementation

### Step 1: Run Database Migration

```bash
# Connect to PostgreSQL
docker compose exec postgres psql -U parking -d parking_v5

# Run migration
\i /docker-entrypoint-initdb.d/002_multi_tenancy_rbac.sql

# Verify tables were created
\dt tenants sites users user_memberships

# Check default tenant was created
SELECT * FROM tenants WHERE slug = 'default';
```

### Step 2: Update main.py

Add the new router and initialize auth:

```python
# In src/main.py

from src.api_tenants import router as tenants_router
from src.tenant_auth import set_db_pool as set_tenant_auth_db_pool, set_jwt_secret
from src.config import config

# After creating the FastAPI app
app.include_router(tenants_router)

# In startup event (after database pool is created)
@app.on_event("startup")
async def startup():
    # ... existing code ...

    # Initialize tenant auth
    set_tenant_auth_db_pool(db_pool)
    set_jwt_secret(config.SECRET_KEY)

    logger.info("Multi-tenancy authentication initialized")
```

### Step 3: Update Existing Endpoints

All existing endpoints need to be updated to:
1. Accept `TenantContext` dependency
2. Add `tenant_id` predicates to database queries
3. Use appropriate role requirements

**Example - Update spaces endpoint:**

```python
# Before
@app.get("/api/v1/spaces")
async def list_spaces(
    db: Pool = Depends(get_db)
):
    rows = await db.fetch("SELECT * FROM spaces WHERE deleted_at IS NULL")
    return rows

# After
from src.tenant_auth import get_current_tenant, require_viewer

@app.get("/api/v1/spaces")
async def list_spaces(
    tenant: TenantContext = Depends(require_viewer),
    db: Pool = Depends(get_db)
):
    rows = await db.fetch("""
        SELECT * FROM spaces
        WHERE tenant_id = $1 AND deleted_at IS NULL
    """, tenant.tenant_id)
    return rows
```

### Step 4: Update Space Creation

Spaces must now belong to a site:

```python
@app.post("/api/v1/spaces")
async def create_space(
    space_create: SpaceCreate,
    tenant: TenantContext = Depends(require_admin),
    db: Pool = Depends(get_db)
):
    # Verify site belongs to tenant
    site = await db.fetchrow("""
        SELECT id FROM sites
        WHERE id = $1 AND tenant_id = $2 AND is_active = true
    """, space_create.site_id, tenant.tenant_id)

    if not site:
        raise HTTPException(
            status_code=404,
            detail="Site not found or does not belong to your tenant"
        )

    # Create space (tenant_id will be auto-populated by trigger)
    row = await db.fetchrow("""
        INSERT INTO spaces (name, code, site_id, ...)
        VALUES ($1, $2, $3, ...)
        RETURNING *
    """, space_create.name, space_create.code, space_create.site_id, ...)

    return Space(**dict(row))
```

### Step 5: Update Uplink Processing

Webhook endpoints should resolve tenant from space:

```python
@app.post("/api/v1/uplink")
async def process_uplink(
    uplink_data: dict,
    db: Pool = Depends(get_db)
):
    device_eui = uplink_data["deviceInfo"]["devEui"]

    # Find space and tenant
    space = await db.fetchrow("""
        SELECT id, tenant_id, site_id, state
        FROM spaces
        WHERE sensor_eui = $1 AND deleted_at IS NULL
    """, device_eui)

    if not space:
        logger.warning(f"Uplink from unknown device: {device_eui}")
        # Handle ORPHAN device...
        return {"status": "orphan", "device_eui": device_eui}

    # Apply tenant-specific rate limiting
    from src.rate_limit import get_rate_limiter
    rate_limiter = get_rate_limiter()

    allowed, headers = await rate_limiter.check_tenant_rate_limit(
        tenant_id=str(space['tenant_id']),
        limit_type='webhook',
        requests_per_minute=600  # 10 QPS
    )

    if not allowed:
        raise HTTPException(status_code=429, detail="Rate limit exceeded")

    # Process uplink...
```

### Step 6: Update Config

Add JWT secret to `.env`:

```bash
# In .env file

# JWT Secret for user authentication (generate with: openssl rand -hex 32)
JWT_SECRET_KEY=your-64-character-hex-secret-here

# Existing config...
DATABASE_URL=...
SECRET_KEY=...
```

### Step 7: Testing

```bash
# 1. Register a new user and tenant
curl -X POST http://localhost:8000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@example.com",
    "name": "Admin User",
    "password": "securepassword123",
    "tenant": {
      "name": "Acme Corp",
      "slug": "acme"
    }
  }'

# 2. Login
curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "admin@example.com",
    "password": "securepassword123"
  }'

# Save the access_token from response

# 3. Get current tenant info
curl http://localhost:8000/api/v1/tenants/current \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"

# 4. Create a new site
curl -X POST http://localhost:8000/api/v1/sites \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "tenant_id": "your-tenant-id",
    "name": "Downtown Parking Garage",
    "timezone": "America/Los_Angeles",
    "location": {"address": "123 Main St", "city": "San Francisco"}
  }'

# 5. Create API key
curl -X POST http://localhost:8000/api/v1/api-keys \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Production API Key",
    "tenant_id": "your-tenant-id"
  }'

# 6. Use API key to access endpoints
curl http://localhost:8000/api/v1/spaces \
  -H "X-API-Key: YOUR_API_KEY"
```

---

## Acceptance Criteria

### ✅ Implemented
- [x] Database schema with tenant isolation
- [x] User authentication with JWT
- [x] API key authentication with tenant scoping
- [x] RBAC with 4 role levels
- [x] Tenant/site/user management APIs
- [x] Per-tenant rate limiting support
- [x] Backward compatibility (default tenant/site)

### ⚠️ Remaining Tasks
- [ ] Update all existing API endpoints with tenant scoping
- [ ] Add tenant_id predicates to all database queries
- [ ] Integrate rate limiting into webhook endpoints
- [ ] Add user invitation system (email invites)
- [ ] Add SSO support (optional, future)
- [ ] Add billing integration (optional, future)
- [ ] Comprehensive testing suite

---

## Security Considerations

### Tenant Isolation
- **Database Level:** Every query MUST include `tenant_id` predicate
- **Application Level:** `TenantContext` dependency enforces isolation
- **Rate Limiting:** Per-tenant limits prevent abuse

### Authentication
- **JWT Tokens:** 24-hour expiry, signed with `JWT_SECRET_KEY`
- **API Keys:** Bcrypt-hashed, stored in database, tied to tenant
- **Passwords:** Bcrypt-hashed with 12 rounds

### Best Practices
1. **Never skip tenant checks** - Always use `get_current_tenant()` dependency
2. **Validate site ownership** - When creating spaces, verify site belongs to tenant
3. **Log security events** - Log all authentication failures and access denials
4. **Rate limit per tenant** - Prevent one tenant from affecting others
5. **Rotate API keys regularly** - Encourage users to rotate keys

---

## Monitoring & Observability

### Metrics to Track
- **Authentication:**
  - Login attempts (success/failure)
  - JWT token validations
  - API key usage per tenant

- **Tenant Activity:**
  - Spaces per tenant
  - Reservations per tenant
  - API requests per tenant
  - Rate limit violations

- **Performance:**
  - Tenant resolution time
  - Database query performance with tenant_id predicates

### Logging
All authentication events are logged with:
- Tenant ID
- User ID (if JWT)
- API key name (if API key)
- Source IP
- Timestamp

---

## Migration Path for Existing Data

### Option 1: Migrate to Default Tenant (Easiest)
All existing data has been linked to the default tenant automatically:
- Default tenant: `id='00000000-0000-0000-0000-000000000001', slug='default'`
- Default site: `id='00000000-0000-0000-0000-000000000001'`

**To migrate:**
```sql
-- Already done in migration script
-- All existing api_keys and spaces are linked to default tenant/site
```

### Option 2: Split into Multiple Tenants (Manual)
```sql
-- Create new tenant
INSERT INTO tenants (name, slug) VALUES ('Tenant A', 'tenant-a');

-- Create site
INSERT INTO sites (tenant_id, name) VALUES
  ((SELECT id FROM tenants WHERE slug = 'tenant-a'), 'Main Site');

-- Move spaces
UPDATE spaces
SET site_id = (SELECT id FROM sites WHERE name = 'Main Site')
WHERE building = 'Building A';

-- Move API keys
UPDATE api_keys
SET tenant_id = (SELECT id FROM tenants WHERE slug = 'tenant-a')
WHERE key_name LIKE 'Tenant A%';
```

---

## API Reference

### Authentication Flow

```
User Registration → User + Tenant Created → Login → JWT Token
                                              ↓
                                   Use Token in Bearer Header
                                              ↓
                                     Access Protected APIs
```

### API Key Flow

```
Owner Creates API Key → Plain Key Returned (save it!)
                              ↓
                    Use Key in X-API-Key Header
                              ↓
                       Access Protected APIs
```

### Multi-Tenant Access Pattern

```python
# Every protected endpoint follows this pattern:

@app.get("/api/v1/resource")
async def get_resource(
    tenant: TenantContext = Depends(require_role(UserRole.VIEWER)),
    db: Pool = Depends(get_db)
):
    # tenant.tenant_id is automatically resolved from JWT or API key
    # tenant.user_role is checked against required role

    rows = await db.fetch("""
        SELECT * FROM resource
        WHERE tenant_id = $1
    """, tenant.tenant_id)

    return rows
```

---

## Troubleshooting

### "Authentication required" error
- Check JWT token is not expired
- Verify Bearer token format: `Authorization: Bearer <token>`
- Or verify API key header: `X-API-Key: <key>`

### "Insufficient permissions" error
- Check user role in tenant: `GET /api/v1/tenants/current`
- Verify endpoint requires appropriate role
- API keys have ADMIN-level access by default

### "Tenant not found" error
- Verify tenant is active: `SELECT * FROM tenants WHERE id = '...'`
- Check user membership is active: `SELECT * FROM user_memberships WHERE user_id = '...'`

### Spaces not visible after migration
- Check spaces have `site_id`: `SELECT id, code, site_id, tenant_id FROM spaces`
- Trigger should auto-populate `tenant_id` when `site_id` is set
- Manually fix: `UPDATE spaces SET site_id = '<default-site-id>' WHERE site_id IS NULL`

---

## Next Steps

1. **Complete endpoint updates** - Update all existing endpoints with tenant scoping
2. **Add comprehensive tests** - Test tenant isolation, RBAC, rate limiting
3. **Deploy to staging** - Test with real data
4. **Documentation** - Update API docs with authentication examples
5. **Monitor metrics** - Track tenant activity and performance

---

## Support

For questions or issues:
- Check logs: `docker compose logs api`
- Review database state: `SELECT * FROM tenant_summary`
- Verify user permissions: `SELECT * FROM user_permissions WHERE email = '...'`

---

**Last Updated:** 2025-10-19
**Implemented By:** Claude Code Assistant
**Status:** Core implementation complete, integration pending
